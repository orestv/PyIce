#!/usr/bin/python2

import gtk, pygtk
import gobject
import threading
import time
from retriever import Retriever

class ClientWindow(gtk.Window):
    def __init__(self):
        super(ClientWindow, self).__init__()

        self._cancel_func = None

        self.connect('destroy', self.destroy)

        self._r = None

        self._create_gui()

    def _load_collection(_self):
        print 'Loading collection...'
        class CollectionFiller(threading.Thread):
            def __init__(self):
                threading.Thread.__init__(self)
                self._stop = threading.Event()

            def stop(self):
                print 'stop!'
                self._stop.set()

            def stopped(self):
                return self._stop.is_set()

            def run(self):
                print 'Thread started'
                col = _self._r.get_collection(self.stopped)
                if self.stopped():
                    return None
                print 'Collection fetched'
                id, collection = col
                for c in collection:
                    _self._lsCollection.append(c)
                _self._operation_over()

        f = CollectionFiller()
        _self._init_operation_button(f.stop, 'Fetching collection...')
        _self._set_cancel_func(f.stop)
        f.start()

    def _request_server_address(self):
        dlg = gtk.Dialog('Server hostname and port', self, 0,
                         (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                          gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))

        tbl = gtk.Table(2, 2, False)

        eHost = gtk.Entry()
        eHost.set_text('213.130.28.169')
        ePort = gtk.Entry()
        ePort.set_text('30000')

        tbl.attach(gtk.Label('Hostname'), 0, 1, 0, 1)
        tbl.attach(eHost, 1, 2, 0, 1)
        tbl.attach(gtk.Label('Port'), 0, 1, 1, 2)
        tbl.attach(ePort, 1, 2, 1, 2)

        dlg.vbox.pack_end(tbl)

        dlg.show_all()

        while 1:
            ret = dlg.run()
            if ret == gtk.RESPONSE_REJECT:
                return None
            elif ret == gtk.RESPONSE_ACCEPT:
                host = eHost.get_text()
                port = ePort.get_text()
                try:
                    port = int(port)
                except ValueError:
                    continue
                dlg.destroy()
                return (host, port)


    def _create_gui(self):
        self.set_size_request(500, 400)
        self.set_position(gtk.WIN_POS_CENTER)

        self.add(self._create_window_toplevel())        

        self.show_all()

    def _operation_over(self):
        if self._sb_handler:
            self._sb.pop(self._sb_context)
        self._btnCancelOperation.hide()

    def _btnCancelOperation_clicked(self, widget):
        if self._cancel_func:
            self._cancel_func()
        self._operation_over()

    def _create_status_bar(self):
        sb = gtk.Statusbar()
        self._sb_context = sb.get_context_id('Current operation')
        self._sb_handler = None
        self._btnCancelOperation = gtk.Button(stock = gtk.STOCK_CANCEL)
        self._btnCancelOperation.hide()
        self._btnCancelOperation.\
                connect('clicked', self._btnCancelOperation_clicked)
        sb.pack_end(self._btnCancelOperation, False, False)
        return sb

    def _set_cancel_func(self, func):
        self._cancel_func = func

    def _init_operation_button(self, func=None, sName=''):
        self._sb_handler = self._sb.push(self._sb_context, sName)
        self._btnCancelOperation.connect('clicked', 
                                        self._btnCancelOperation_clicked)
        self._btnCancelOperation.show()

    def btnConnect_clicked(self, button):
        host, port = self.eHost.get_text(), int(self.ePort.get_text())
        self._r = Retriever(host, port)
        self._tblContent.set_sensitive(True)
        self._load_collection()

    def _create_window_toplevel(self):
        vbox = gtk.VBox()

        hbox = gtk.HBox()

        self.eHost = gtk.Entry()
        self.eHost.set_text('213.130.28.169')
        self.ePort = gtk.Entry()
        self.ePort.set_text('30000')
        
        hbox.pack_start(gtk.Label('Host'))
        hbox.pack_start(self.eHost)
        hbox.pack_start(gtk.Label('Port'))
        hbox.pack_start(self.ePort)
        
        btnConnect = gtk.Button('Connect')
        hbox.pack_start(btnConnect, fill=False, expand=False)
        btnConnect.connect('clicked', self.btnConnect_clicked)

        vbox.pack_start(hbox, fill=False, expand=False)

        tbl = gtk.Table(2,3,False)
        tbl.set_col_spacings(5)
        tbl.set_row_spacings(5)

        self._tvPlaylist, self._lsPlaylist = self.create_playlist_view()
        self._tvCollection, self._lsCollection = self.create_collection_view()

        sw = gtk.ScrolledWindow()
        sw.add_with_viewport(self._tvPlaylist)

        tbl.attach(sw, 0, 1, 0, 1)


        sw = gtk.ScrolledWindow()
        sw.add_with_viewport(self._tvCollection)

        tbl.attach(sw, 1, 2, 0, 1)

        self._sb = self._create_status_bar()

        tbl.attach(self._sb, 0, 2, 1, 2, yoptions=0)

        vbox.pack_end(tbl)
        tbl.set_sensitive(False)

        self._tblContent = tbl

        return vbox


    def create_collection_view(self):
        tvCollection = gtk.TreeView()

        columns = [ {'title': 'Artist-Title', 'type': str},
                    {'title': 'Path', 'type': str}]

        col_types = [x['type'] for x in columns]

        lsCollection = gtk.ListStore(*col_types)

        for i in range(len(columns)):
            col = columns[i]
            renderer = gtk.CellRendererText()
            c = gtk.TreeViewColumn(col['title'], renderer)
            tvCollection.append_column(c)
            c.add_attribute(renderer, 'text', i)

        tvCollection.set_model(lsCollection)

        return tvCollection, lsCollection

    def create_playlist_view(self):
        tvPlaylist = gtk.TreeView()

        columns = [{'title': 'Song', 'type': str},
                   {'title': 'Length', 'type': str}]

        col_types = [x['type'] for x in columns]

        lsPlaylist = gtk.ListStore(*col_types)

        for i in range(len(columns)):
            col = columns[i]
            renderer = gtk.CellRendererText()
            c = gtk.TreeViewColumn(col['title'], renderer)
            tvPlaylist.append_column(c)
            c.add_attribute(renderer, 'text', i)

        tvPlaylist.set_model(lsPlaylist)

        return tvPlaylist, lsPlaylist


    def destroy(self, widget):
        gtk.main_quit()


if __name__ == '__main__':
    c = ClientWindow()
    gobject.threads_init()
    gtk.main()

