#!/usr/bin/python

import gtk, pygtk
import gobject
import threading
import time
from retriever import Retriever

class ClientWindow(gtk.Window):
    def __init__(self):
        super(ClientWindow, self).__init__()

        self.connect('destroy', self.on_destroy)
        self._current_song = None
        self._current_song_lock = threading.Lock()
        self._lsThreads = []

        self._init_gui()

    def _init_gui(self):
        self.set_size_request(600, 400)
        self.set_position(gtk.WIN_POS_CENTER)
        bxMain = gtk.VBox()

        bxLogin = gtk.HBox()
        
        eHost = gtk.Entry()
        ePort = gtk.Entry()
        btnConnect = gtk.Button('Connect')

        eHost.set_text('213.130.28.169')
        ePort.set_text('30000')

        bxLogin.pack_start(gtk.Label('Host:'))
        bxLogin.pack_start(eHost)
        bxLogin.pack_start(gtk.Label('Port:'))
        bxLogin.pack_start(ePort)
        bxLogin.pack_start(btnConnect)

        bxMain.pack_start(bxLogin, expand=False, fill=False)

        self._lblCurrentSong = gtk.Label()
        self._lblCountdown = gtk.Label()
        bxCurrent = gtk.HBox()

        bxCurrent.pack_start(gtk.Label('Currently playing:'))
        bxCurrent.pack_start(self._lblCurrentSong)
        bxCurrent.pack_start(gtk.Label('Ends in '))
        bxCurrent.pack_start(self._lblCountdown)

        bxMain.pack_start(bxCurrent, expand=False, fill=False, padding=15)

        tbl = gtk.Table(3,4,False)

        columns = [{'title': 'Path',
                    'type': str, 'visible': False},
                   {'title': 'Song',
                    'type': str, 'visible': True},
                   {'title': 'Length',
                    'type': str, 'visible': True}
                  ]

        self._tsCollection, self._tvCollection = \
                create_treeview(columns, True)
        self._tvCollection.enable_model_drag_source(
            gtk.gdk.BUTTON1_MASK,[('text/plain', 0, 0)],
            gtk.gdk.ACTION_DEFAULT|gtk.gdk.ACTION_COPY)

        def drag_data_get(treeview, context, selection, info, timestamp):
            sel = treeview.get_selection()
            model, iter = sel.get_selected()
            data = model.get_value(iter, 0)
            selection.set(selection.target, 8, data)
            return

        self._tvCollection.connect('drag-data-get', drag_data_get)

        columns = [{'title': 'Path',
                    'type': str, 'visible': False},
                   {'title': 'Artist',
                    'type': str, 'visible': True},
                   {'title': 'Title',
                    'type': str, 'visible': True},
                   {'title': 'Length',
                    'type': str, 'visible': True},
                   {'title': 'Start time',
                    'type': str, 'visible': True},
                   {'title': 'End time',
                    'type': str, 'visible': True}
                  ]

        self._lsPlaylist, self._tvPlaylist = \
                create_treeview(columns)
        self._tvPlaylist.enable_model_drag_dest(
            [('text/plain', 0, 0)], gtk.gdk.ACTION_DEFAULT|gtk.gdk.ACTION_COPY)

        def drag_data_received(treeview, context, x, y, selection, info,
                               timestamp):
            drop_info = treeview.get_dest_row_at_pos(x, y)
            data = selection.data
            print 'Drag-drop received'
            if not data:
                return
            print 'DnD data is %s' % (data,)
            index, position = drop_info
            print 'DnD: dropped at ', index
            print 'DnD: position: ', position
            if not index:
                model = treeview.get_model()
                nSongs = model.iter_n_children(None)
                index = nSongs
            else:
                index = index[0]
                if position in (gtk.TREE_VIEW_DROP_AFTER,
                                gtk.TREE_VIEW_DROP_INTO_OR_AFTER):
                    index += 1
            print 'DnD: inserting into ', index
            result = self._r.insert_songs(index, (data,))
            print 'DnD: inserted? ', result
            self.update_playlist()
            return


        self._tvPlaylist.connect('drag-data-received', drag_data_received)

        btnReloadCollection = gtk.Button('Reload')

        def btnReloadCollection_clicked(button):
            self.download_collection()

        btnReloadCollection.connect('clicked', btnReloadCollection_clicked)

        sw = gtk.ScrolledWindow()
        sw.add(self._tvCollection)
        tbl.attach(gtk.Label('Collection'), 0, 1, 0, 1, 0, 0)
        tbl.attach(btnReloadCollection, 1, 2, 0, 1, 0, 0)
        tbl.attach(sw, 0, 2, 1, 2)

        def tvCollection_row_activated(view, row, column):
            iter = self._tsCollection.get_iter(row)
            path = self._tsCollection.get_value(iter, 0)
            self._r.set_next_song(path)
            self.update_playlist()

        self._tvCollection.connect('row-activated', tvCollection_row_activated)

        btnReloadPlaylist = gtk.Button('Reload')

        def btnReloadPlaylist_clicked(button):
            self.update_playlist()

        btnReloadPlaylist.connect('clicked', btnReloadPlaylist_clicked)

        sw = gtk.ScrolledWindow()
        sw.add(self._tvPlaylist)
        tbl.attach(gtk.Label('Playlist'), 2, 3, 0, 1, 0, 0)
        tbl.attach(btnReloadPlaylist, 3, 4, 0, 1, 0, 0)
        tbl.attach(sw, 2, 4, 1, 2)

        tbl.set_sensitive(False)

        bxMain.pack_start(tbl)

        self._status = gtk.VBox()
        bxMain.pack_end(self._status, expand=False, fill=False)

        def btnConnect_clicked(button):
            host, port = eHost.get_text(), int(ePort.get_text())
            try:
                self._r = Retriever(host, port)
                bxLogin.set_sensitive(False)
                tbl.set_sensitive(True)
            except:
                print 'Connection refused'
                return
            self.download_collection()
            self.update_playlist()
            self.update_current_song()
            self.start_counter()


        btnConnect.connect('clicked', btnConnect_clicked)

        self.add(bxMain)
        self.show_all()

    def upload_playlist(self):
        row = self._lsPlaylist.get_iter_first()
        pl = []
        while row:
            pl.append(self._lsPlaylist.get_value(row, 0))
            row = self._lsPlaylist.iter_next(row)

        print pl

    def update_current_song(self):

        #def fUpdateSong(fStopped):
        with self._current_song_lock:
            self._current_song = self._r.get_current_song()
        if self._current_song:
            def f():
                self._lblCurrentSong.set_text(self._current_song['artist']+' - '\
                                              +self._current_song['title'])
            gobject.idle_add(f)

        #tSong = LocalThread(self, fUpdateSong)
        #tSong.start()


    def start_counter(self):
        def update_counter(text):
            self._lblCountdown.set_text(text)

        def fUpdateCounter(fStopped):
            nMax = 25
            nCount = nMax
            while 1:
                while 1:
                    nCount += 1
                    if fStopped():
                        return
                    if nCount >= nMax:
                        nCount = 0
                        self.update_current_song()
                        with self._current_song_lock:
                            if self._current_song:
                                end_time = self._current_song['end_time']
                    timer = self._current_song['end_time'] - time.time()
                    if timer < 0:
                        time.sleep(1)
                        nCount = nMax
                        break
                    t = format_length(timer)
                    gobject.idle_add(update_counter, t)

                    time.sleep(0.1)
                        #self.update_playlist()
                t = self.update_playlist()
                t.join()

        tCounter = LocalThread(self, fUpdateCounter)
        tCounter.start()


    def download_collection(self):
        def f(fStopped):
            result = self._r.get_collection(fStopped)
            if not result:
                return False
            col = result
            self._tvCollection.set_model(None)
            for artist in col:
                rwArtist = self._tsCollection.append(None, 
                                                ['', artist, ''])
                for album in col[artist]:
                    rwAlbum = self._tsCollection.append(rwArtist,
                                                        ['', album, ''])
                    for song in col[artist][album]:
                        self._tsCollection.append(rwAlbum,
                                                  [song['path'], song['title'],
                                                  format_length(song['length'])])
            self._tvCollection.set_model(self._tsCollection)
            return True
        return self._run(f, 'Downloading collection...', \
                  'Collection downloaded successfully!', \
                  'Failed to download collection!')

    def update_playlist(self):
        def f(fStopped):
            result = self._r.get_playlist(fStopped)
            if not result:
                self._tvPlaylist.set_sensitive(True)
                return False
            pl = result
            def fGUI():
                #next song will start as soon as the curent ends
                start_time = self._current_song['end_time'] 
                print start_time
                self._tvPlaylist.set_sensitive(False)
                self._tvPlaylist.set_model(None)
                self._lsPlaylist.clear()
                for c in pl:
                    self._lsPlaylist.append(
                        [c['path'], c['tags']['artist'], c['tags']['title'],
                         format_length(c['length']), 
                         format_time(start_time), 
                         format_time(c['length']+start_time)])
                    start_time += c['length']

                self._tvPlaylist.set_model(self._lsPlaylist)
                self._tvPlaylist.set_sensitive(True)
            gobject.idle_add(fGUI)
            return True

        return self._run(f, 'Downloading playlist...', \
                  'Playlist downloaded successfully!',
                  'Failed to download playlist!')

    def _run(self, func, msgStatus, msgSuccess, msgFail):
        box = gtk.HBox()
        print box
        lblStatus = gtk.Label(msgStatus)
        print lblStatus
        btnCancel = gtk.Button(stock=gtk.STOCK_CANCEL)
        print btnCancel
        box.pack_start(lblStatus)
        box.pack_start(btnCancel)
        self._status.pack_start(box)
        box.show_all()


        def fTarget(fStopped):
            result = func(fStopped)
            if result:
                lblStatus.set_text(msgSuccess)
            else:
                lblStatus.set_text(msgFail)
            btnCancel.set_sensitive(False)
            time.sleep(2)
            box.destroy()

        t = LocalThread(self, fTarget)

        def btnCancel_clicked(button):
            t.stop()

        btnCancel.connect('clicked', btnCancel_clicked)

        t.start()
        return t

    def add_thread(self, thread):
        self._lsThreads.append(thread)

    def remove_thread(self, thread):
        self._lsThreads.remove(thread)

    def on_destroy(self, event):
        for thread in self._lsThreads:
            print 'Stopping an orphaned thread...'
            thread.stop()
            thread.join()
            print 'Thread stopped'
        gtk.main_quit()

def create_treeview(columns, tree=False):
    tv = gtk.TreeView()
    if tree:
        ls = gtk.TreeStore(*[col['type'] for col in columns])
    else:
        ls = gtk.ListStore(*[col['type'] for col in columns])
    for i in range(len(columns)):
        col = columns[i]
        renderer = gtk.CellRendererText()
        c = gtk.TreeViewColumn(col['title'], renderer)
        c.set_resizable(True)
        c.set_expand(False)
        if not col['visible']:
            c.set_visible(False)
        tv.append_column(c)
        c.add_attribute(renderer, 'text', i)
        tv.set_model(ls)
    return ls, tv

class LocalThread(threading.Thread):
    def __init__(self, window, target):
        threading.Thread.__init__(self)
        self._window = window
        self._e = threading.Event()
        self._target = target

    def stopped(self):
        return self._e.is_set()

    def stop(self):
        print 'Thread stop() called.'
        self._e.set()

    def run(self):
        self._window.add_thread(self)
        self._target(self.stopped)
        self._window.remove_thread(self)

def format_length(length):
    t = time.strftime('%M:%S', time.localtime(length))
    return t

def format_time(length):
    t = time.strftime('%H:%M:%S', time.localtime(length))
    return t

if __name__ == '__main__':
    gtk.gdk.threads_init()
    c = ClientWindow()
    gtk.main()
