#!/usr/bin/python

import gtk, pygtk
import gobject
import threading
import time
from retriever import Retriever

class ClientWindow(gtk.Window):
    def __init__(self):
        super(ClientWindow, self).__init__()

        self.connect('destroy', self.on_destroy)
        self._current_song = None
        self._lsThreads = []

        self._init_gui()

    def _init_gui(self):
        self.set_size_request(600, 400)
        self.set_position(gtk.WIN_POS_CENTER)
        bxMain = gtk.VBox()

        bxLogin = gtk.HBox()
        
        eHost = gtk.Entry()
        ePort = gtk.Entry()
        btnConnect = gtk.Button('Connect')

        eHost.set_text('213.130.28.169')
        ePort.set_text('30000')

        bxLogin.pack_start(gtk.Label('Host:'))
        bxLogin.pack_start(eHost)
        bxLogin.pack_start(gtk.Label('Port:'))
        bxLogin.pack_start(ePort)
        bxLogin.pack_start(btnConnect)

        bxMain.pack_start(bxLogin, expand=False, fill=False)

        self._lblCurrentSong = gtk.Label()
        self._lblCountdown = gtk.Label()
        bxCurrent = gtk.HBox()

        bxCurrent.pack_start(gtk.Label('Currently playing:'))
        bxCurrent.pack_start(self._lblCurrentSong)
        bxCurrent.pack_start(gtk.Label('Ends in '))
        bxCurrent.pack_start(self._lblCountdown)

        bxMain.pack_start(bxCurrent, expand=False, fill=False)

        tbl = gtk.Table(2,2,False)

        columns = [{'title': 'Path',
                    'type': str, 'visible': False},
                   {'title': 'Song',
                    'type': str, 'visible': True}
                  ]

        self._tsCollection, self._tvCollection = \
                create_treeview(columns, True)


        columns = [{'title': 'Path',
                    'type': str, 'visible': False},
                   {'title': 'Artist',
                    'type': str, 'visible': True},
                   {'title': 'Title',
                    'type': str, 'visible': True},
                   {'title': 'Length',
                    'type': str, 'visible': True}]

        self._lsPlaylist, self._tvPlaylist = \
                create_treeview(columns)

        sw = gtk.ScrolledWindow()
        sw.add(self._tvCollection)
        tbl.attach(sw, 0, 1, 0, 1)

        def tvCollection_row_activated(view, row, column):
            iter = self._tsCollection.get_iter(row)
            path = self._tsCollection.get_value(iter, 0)
            self._r.set_next_song(path)
            self.update_playlist()

        self._tvCollection.connect('row-activated', tvCollection_row_activated)

        sw = gtk.ScrolledWindow()
        sw.add(self._tvPlaylist)
        tbl.attach(sw, 1, 2, 0, 1)

        tbl.set_sensitive(False)

        bxMain.pack_start(tbl)


        self._btnCancel = gtk.Button(stock=gtk.STOCK_CANCEL)
        self._btnCancel.set_sensitive(False)

        self._status = gtk.VBox()
        bxMain.pack_end(self._status, expand=False, fill=False)

        def btnCancel_clicked(button):
            print 'btnCancel onclick handler!'
            if self._fCancel:
                self._fCancel()

        def btnConnect_clicked(button):
            host, port = eHost.get_text(), int(ePort.get_text())
            try:
                self._r = Retriever(host, port)
                bxLogin.set_sensitive(False)
                tbl.set_sensitive(True)
            except:
                print 'Connection refused'
                return
            self.download_collection()
            self.update_playlist()
            self.update_current_song()
            self.start_counter()


        self._btnCancel.connect('clicked',  btnCancel_clicked)
        btnConnect.connect('clicked', btnConnect_clicked)

        self.add(bxMain)
        self.show_all()

    def update_current_song(self):

        #def fUpdateSong(fStopped):
        self._current_song = self._r.get_current_song()
        if self._current_song:
            self._lblCurrentSong.set_text(self._current_song['artist']+' - '\
                                          +self._current_song['title'])

        #tSong = LocalThread(self, fUpdateSong)
        #tSong.start()


    def start_counter(self):
        def fUpdateCounter(fStopped):
            while 1:
                if fStopped():
                    break
                if self._current_song:
                    timer = self._current_song['end_time'] - time.time()
                    if timer < 0:
                        self.update_current_song()
                        self.update_playlist()
                    t = time.strftime('%M:%S', time.localtime(timer))
                    self._lblCountdown.set_text(t)
                time.sleep(0.1)

        tCounter = LocalThread(self, fUpdateCounter)
        tCounter.start()


    def download_collection(self):
        def f(fStopped):
            result = self._r.get_collection(fStopped)
            if not result:
                return False
            col = result
            for artist in col:
                rwArtist = self._tsCollection.append(None, 
                                                ['', artist])
                for album in col[artist]:
                    rwAlbum = self._tsCollection.append(rwArtist,
                                                        ['', album])
                    for song in col[artist][album]:
                        self._tsCollection.append(rwAlbum,
                                                  [song['path'], song['title']])

            #list = [(c['path'], c['tags']['artist'], c['tags']['title'], '')\
            #        for c in col]
            #def fGUI():
            #    self._tvCollection.set_model(None)
            #    for c in list:
            #        self._tsCollection.append(c)
            #    self._tvCollection.set_model(self._tsCollection)
            #self._tsCollection.clear()
            #gobject.idle_add(fGUI)
            return True
        self._run(f, 'Downloading collection...', \
                  'Collection downloaded successfully!', \
                  'Failed to download collection!')

    def update_playlist(self):
        def f(fStopped):
            self._tvPlaylist.set_sensitive(False)
            result = self._r.get_playlist(fStopped)
            if not result:
                self._tvPlaylist.set_sensitive(True)
                return False
            pl = result
            pl = [(c['path'], c['tags']['artist'], c['tags']['title'], c['length']) for c in pl]
            def fGUI():
                self._tvPlaylist.set_model(None)
                for c in pl:
                    self._lsPlaylist.append(c)
                self._tvPlaylist.set_model(self._lsPlaylist)
            self._lsPlaylist.clear()
            gobject.idle_add(fGUI)
            self._tvPlaylist.set_sensitive(True)
            return True

        self._run(f, 'Downloading playlist...', \
                  'Playlist downloaded successfully!',
                  'Failed to download playlist!')

    def _run(self, func, msgStatus, msgSuccess, msgFail):
        box = gtk.HBox()
        print box
        lblStatus = gtk.Label(msgStatus)
        print lblStatus
        btnCancel = gtk.Button(stock=gtk.STOCK_CANCEL)
        print btnCancel
        box.pack_start(lblStatus)
        box.pack_start(btnCancel)
        self._status.pack_start(box)
        box.show_all()


        def fTarget(fStopped):
            result = func(fStopped)
            if result:
                lblStatus.set_text(msgSuccess)
            else:
                lblStatus.set_text(msgFail)
            btnCancel.set_sensitive(False)
            time.sleep(2)
            box.destroy()

        t = LocalThread(self, fTarget)

        def btnCancel_clicked(button):
            t.stop()

        btnCancel.connect('clicked', btnCancel_clicked)

        t.start()

    def add_thread(self, thread):
        self._lsThreads.append(thread)

    def remove_thread(self, thread):
        self._lsThreads.remove(thread)

    def on_destroy(self, event):
        for thread in self._lsThreads:
            thread.stop()
        gtk.main_quit()

def create_treeview(columns, tree=False):
    tv = gtk.TreeView()
    if tree:
        ls = gtk.TreeStore(*[col['type'] for col in columns])
    else:
        ls = gtk.ListStore(*[col['type'] for col in columns])
    for i in range(len(columns)):
        col = columns[i]
        renderer = gtk.CellRendererText()
        c = gtk.TreeViewColumn(col['title'], renderer)
        c.set_resizable(True)
        c.set_expand(False)
        if not col['visible']:
            c.set_visible(False)
        tv.append_column(c)
        c.add_attribute(renderer, 'text', i)
        tv.set_model(ls)
    return ls, tv

class LocalThread(threading.Thread):
    def __init__(self, window, target):
        threading.Thread.__init__(self)
        self._window = window
        self._e = threading.Event()
        self._target = target

    def stopped(self):
        return self._e.is_set()

    def stop(self):
        print 'Thread stop() called.'
        self._e.set()

    def run(self):
        self._window.add_thread(self)
        self._target(self.stopped)
        self._window.remove_thread(self)


if __name__ == '__main__':
    gtk.gdk.threads_init()
    c = ClientWindow()
    gtk.main()
